#' Convert a Sawtooth Software generated design file tp a dummy coded design
#' file
#'
#' Take a design file such as those generated by the Sawtooth Software
#' Lighthouse Studio and convert it into a dummy coded design file.  The last
#' level in the attribute is considered the reference level and will be dropped.
#'
#' This function is written to not require converting columns to be factors. All
#' variables should be numeric indexes for the levels of the attributes. If you
#' would like to manually code a attribute of the design, for example if you
#' have a price variable, you must manually code that attribute and then can
#' call the function with the optional columns to code parameter.
#'
#' @seealso
#' /url{http://www.sawtoothsoftware.com/help/lighthouse-studio/manual/index.html?hid_web_cbc_exporting.html}
#'
#'
#' Documentation for the Sawtooth Software Design file format can be found at
#' @param sawtoothDesign A matrix that contains the Sawtooth design.  Can be
#'   loaded with read.csv.
#' @param columnsToCode (Optional, Default = all columns) A vector listing the
#'   numeric index of the columns to code. Note: The first column is column 4
#'   due to the control variables
#' @param includeNoneOption (Optional, Default = FALSE) A boolean value
#'   indicating whether to expand the task to include a none option
#' @return A matrix object chat contains the dummy coded design file.  The last
#'   attribute is considered the reference level
#'
#' @examples
#' \dontrun{
#'  # Read in the Sawtooth Formatted data
#'  design <- read.csv("Design.csv")
#'  prices = c(0.79, 1.29, 1.79, 2.29, 2.79)
#'  design$price <- prices[design$price]
#'  codedDesign <- codeSawtoothDesignFile(design, c(4:9))
#' }
#'
#'
codeSawtoothDesignFile <- function(sawtoothDesign, columnsToCode = c(4:ncol(sawtoothDesign)), includeNoneOption=FALSE) {
  dummyCode <- function(column) {
    nLevels <- max(column)
    dummy_code <- diag(nLevels)
    dummy_code <- dummy_code[,-nLevels, drop=FALSE]
    result_columns <- dummy_code[column[[1]],, drop=FALSE]
    colnames(result_columns) <- paste0(names(column), 1:(nLevels - 1))
    result_columns
  }

  dummy_coded_columns = list()
  for(i in 1:ncol(sawtoothDesign)) {
    if(i %in% columnsToCode ) {
      dummy_coded_columns[[i]] <- dummyCode(sawtoothDesign[i])
    } else {
      dummy_coded_columns[[i]] <- sawtoothDesign[i]
    }
  }

  coded_design <- do.call("cbind", dummy_coded_columns)
  if(includeNoneOption) {
    nVersions <- max(coded_design[,1])
    nScenarios <- max(coded_design[,2])
    nConcepts <- max(coded_design[,3])
    versions <- rep(1:nVersions, each=nScenarios)
    scenarios <- rep(1:nScenarios, times=nVersions)
    none_design <- cbind(versions, scenarios, nConcepts+1, matrix(0, ncol=ncol(codedCamera) - 3, nrow =length(versions)))
    colnames(none_design) <- colnames(coded_design)
    coded_design <- rbind(coded_design, none_design)
    coded_design <- coded_design[order(coded_design[,1], coded_design[,2], coded_design[,3]),]
  }

  return(coded_design)
}

#' Convert Package Formatted Data to Bayesm Format
#'
#' Converts a data file and a coded design file from the format expected by the
#' package to a format appropriate for estimation in bayesm
#' \code{\link[bayesm]{rhierMnlRwMixture}}
#'
#' @param data The data.frame or matrix that contains the respondents answers
#' @param design The data.frame or matrix that contains the coded design
#'
#' @return lgtdata The list data structure for use with bayesm
#'
#' @seealso \code{\link{codeSawtoothDesignFile}}
#'
#' @example
#' \dontrun{
#'  data <- read.csv("data.csv")
#'  design <- read.csv("design.csv")
#'  design <- codeSawtoothDesignFile(design)
#'  convert_to_bayesm(data, design)
#' }
convert_to_bayesm <- function(data, design) {
  # lgtdata - a nResp list with
  # lgtdata[[i]]$y - a vector of respondent choices (1,..., p) of length nTasks
  # lgtdata[[i]]$x - a matrix design matrix for the ith unit
  nResp <- nrow(data)

  lgtdata <- list()
  for(i in seq_len(nResp)) {
    versionNumber <- data[i,2]
    y <- data[i,-c(1,2)]
    X <- subset(design, design[,1] == versionNumber)
    nTasks <- max(X[,2])
    nConcepts <- max(X[,3])
    X <- X[,-c(1:3)]
    lgtdata[[i]] <- list(y = y, X = X)
  }

  list(lgtdata = lgtdata, p = nConcepts)
}

# Note: input data is a dataframe, needs following format and variable names: resp.id, ques, alt, choice
# After that, dummy coded design matrix (any names)
# choice is the DV, which is a 1/0 variable
# Need to specify how many holdout observations (nlastq)
convert_df_bayesm <- function(df_in){

  #df_in <- cbc_bayesm.df


  attributes_str <- names(df_in)[5:ncol(df_in)]
  #attributes_str

  # Number of respondents
  Nresp <- length(unique(df_in$resp.id))
  Nresp
  #Number of alternatives
  Nalt <- max(df_in$alt)
  Nalt

  #Number of total questions
  Nques_tot <- max(df_in$ques)
  Nques_tot

  # Number of holdout
  # Take last XXX choice sets as holdout
  # Right now they are not saved; just killed
  # Needs to be set to the same as for JAGS data prep in prep_data_JAGS_with_nochoice_probit()
  nlastq <- 2
  # nlastq <- 4


  if (nlastq>0){
    Nques_tot <- (Nques_tot-nlastq)
  }
  Nques_tot


  cbclgtdata <- NULL
  cbclgtdata_holdout <- NULL
  respids <- unique(df_in$resp.id)

  for (ii in 1:Nresp){

    #ii <- 1
    # Select resp ii
    curresp <- respids[ii]
    curresp

    curdata_all <- df_in[df_in$resp.id==curresp,]

    # Kill the holdout data to generate calibration data; store holdout in separate matrix
    if (nlastq > 0){
      curdata <- curdata_all[(curdata_all$ques<=Nques_tot),]
      curdata_holdout <- curdata_all[(curdata_all$ques>Nques_tot),]
    }

    curdata
    curdata_holdout

    curdata_choice <- rep(NA, times=Nques_tot)
    curdata_choice

    # Loop over choice tasks to get choice = 1,2,...,or Nalt
    for (jj in 1:Nques_tot){
      curdata_task_choice <-curdata[curdata$ques==jj,"choice"]
      curdata_choice[ jj ] <- which.max(curdata_task_choice)
    }


    curdata_choice_holdout <- rep(NA, times=nlastq)
    curdata_choice_holdout

    # Loop over choice tasks holdout to get choice = 1,2,...,or Nalt
    jjcnt <- 1
    for (jj in (Nques_tot+1):(nlastq+Nques_tot)){
      curdata_task_choice <-curdata_holdout[curdata_holdout$ques==jj,"choice"]
      curdata_choice_holdout[ jjcnt ] <- which.max(curdata_task_choice)
      jjcnt <- jjcnt + 1
    }

    curdata_choice_holdout

    #TEMP <- as.matrix(curdata[,attributes_str])
    #unname(TEMP)

    cbclgtdata[[ii]]=list(y=curdata_choice,X= unname(as.matrix(curdata[,attributes_str])))
    cbclgtdata_holdout[[ii]] = list(y=curdata_choice_holdout,X= unname(as.matrix(curdata_holdout[,attributes_str])))

  }


  cbclgtdata_cal_hold <- list(cbclgtdata=cbclgtdata, cbclgtdata_holdout=cbclgtdata_holdout)


  return(cbclgtdata_cal_hold)

}
